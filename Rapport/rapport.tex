\documentclass{article}
\usepackage[francais]{babel}
%\usepackage[latin1]{inputenc}
\usepackage[utf8]{inputenc}  
%\usepackage[T1]{fontenc}
\usepackage[top = 3cm, left = 4cm, right = 4cm ]{geometry}
\usepackage[pdftex]{graphicx}
\usepackage{fancyhdr}
\usepackage{colortbl}
%\usepackage{lscape}
%\usepackage[absolute]{textpos}
%\usepackage{amssymb}



\title{
{\Huge \textbf{Rapport de projet}\\
Algorithmique et bioinformatique}}

\author{\textbf{Sneessens Joachim}\\\textbf{Tulippe-Hecq Arnaud}\\MA1 Info}


\date{Année Académique 2019-2020\\
Master 1 en sciences informatiques\\
\vspace{1cm}
Faculté des Sciences, Université de Mons}


\pagestyle{fancy}
\lhead{Sneessens J. - Tulippe-Hecq A.}
\rhead{MA1 Info}
\cfoot{\thepage}

\begin{document}

\maketitle

\vspace{9cm}

\begin{center}
\begin{tabular}[t]{c c c}
\includegraphics[height=1.5cm]{logoumons.jpg} &
\hspace{1cm} &
\includegraphics[height=1.5cm]{logofs.jpg}
\end{tabular}
\end{center}~\\



\newpage

\section{Introduction}

Dans le cadre du cours d'Algorithmique et Bioinfoormatique donnée par les enseignants Olivier Delgrange et Clément Tamines, nous avons du réaliser un projet qui consiste en la résolution d'un problème lié aux fragment d'ADN.

\subsection{énoncé du problème}

L'objectif de ce projet est l'implémentation en java d'une solution à l'assemblage d'un fragment unique à partir d'une collection de fragments.. Un fragment est une suite de caractère (dont la longueur a été définie entre 500 et 700) composée uniquement des 4 lettres $ A, C, G $ et $T$. Ces fragments seront comparés pour plus tard construire une séquence unique. Cette séquence est évaluée avec l'outil $dotmatcher$ qui détermine la qualité de l'assemblage.


\subsection{Difficultés supllémentaires}

Il faut prendre en compte la grande quatité de données à traiter, ainsi le travail doit efficade en temps mais aussi en mémoire.

On ne sait pas dans quel sens le fragment doit être lu. Pour rappel, l'ADN est composé de deux brins, chacun ayant un sens inersé ($ 3' - 5' et 5' -3'$). Ainsi, il faut également prendre en compte les fragments complémentaires et inversés.

Il y a également différentes erreurs de séquençage qui complique la lecture des fragments.

\section{Répartition du travail}


Ce travail a été réalisé en plusieurs semaines. La quantité de travail à accomplir nous a poussé à avoir recours au logiciel $Git$ afin de pouvoir travailler à distance. De nombreuses séances de travail à l'univertisté ont également été organisées. La totalité des étapes du travail, allant de la réflexion à l'implémentation ont été accomplies en duo.

Malgré un retard marqué par une première séance de mise au point peu développée, nous avons pu progresser à grande vitesse pour pouvoir organiser un seconde mise au point et ainsi nous mettre à jour par rapport au temps restant.

\newpage

\section{\'Etapes clés}

La réalisation du projet s'eefectue en 6 étapes principales : (+++ ITEMIZE ?+++)

\begin{itemize}
\item L'aglignement semi global
\item L'overlap graph : la seconde étape est la construction d'un graphe dont les sommets sont les fragments et les arcs sont les poids des alignements semi globaux
\item 
\item 
\end{itemize}


\subsection{Alignement semi-global}


atgtct
gtcccg

\begin{table}[h]
	\centering
	\begin{tabular}{|c|c|c|c|c|c|c|c|}
		\hline
		 & & G & T & C & C & C & G
		\\\hline
		&0&0&0&0&0&0&0
		\\\hline
        		A&0&-1&-1&-1&-1&-1&-1
		\\\hline
		T&0&-1&0&-1&2&0&0
		\\\hline
		G&0&-1&-2&-1&0&3&1
		\\\hline
		T&0&-1&-2&-3&-2&1&\cellcolor[gray]{0.8}2
		\\\hline
		C&0&-1&-2&-3&-4&-1&0
		\\\hline
		T&0&-1&-2&-1&-3&-3&-2
		\\\hline
	\end{tabular}
\end{table}

\subsection{Overlap graph}

La première étape de cet algorithme est la construction de l'overlap graph. Il s'agit de créer un graphe dont les sommets sont les fragments donnés en entrée et leurs complémentaires-inversés. Ce graphe est orienté et pondéré. Un arc $f\to g$ de poids $w$ existe entre $f$ et $g$ si l'alignement semi-global entre $f$ et $g$ est de poids $w$.

Pour construire ce graphe, il faut donc rechercher l'alignement semi-global optimal pour chaque paire de fragments du graphe (excepté les paires constituées d'un fragment et son complémentaire-inversé). C'est à cette étape que sont détectées les inclusions entre fragments. Nous avons pris le parti de retirer du graphe les fragments inclus à d'autres.

Puisque le graphe est construit dans l'unique but de parcourir les arcs par ordre décroissant pour construire le chemin hamiltonien, nous avons choisi de mettre tous les arcs dans un tas où ils seraient triés en fonction de leur poids.

\textit{PriorityBlockingQueue}\footnote{https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html}

Pour la suite, nous nommerons $f'$ le fragment complémentaire-inversé d'un fragment $g$. 

Chaque nœud d'un graphe contient un fragment $f$ et son complémentaire-inversé $f'$. Ce choix est expliqué dans la section suivante.

Conséquemment, chaque arc du graphe est caractérisé par sa source, sa destination, son poids, un

\subsection{Chemin hamiltonien}

Pour construire le chemin hamiltonien, nous allons retirer successivement sa racine au tas qui contient les arcs pour parcourir les arcs dans l'ordre décroissant. L'algorithme utilisé est très proche de l'algorithme de Kruskal, qui sert à la construction de l'arbre couvrant de poids minimal d'un graphe.
Pendant ce parcours des arcs, un arc $f \to g$ est accepté dans le chemin hamiltonien si :

\begin{itemize}
\item pour tous les arcs $i \to j$ déjà choisis dans le chemin, $i \neq f'$ et $j \neq f'$  ($f'$ étant le complémentaire-inversé de $f$)
\item pour tous les arcs $i \to j$ déjà choisis dans le chemin, $i \neq g'$ et $j \neq g'$  ($g'$ étant le complémentaire-inversé de $g$)
\item ajouter $f \to g$ au chemin ne va pas créer de cycle
\item pour tous les arcs $i \to j$ déjà choisis dans le chemin, $i \neq f$ et $j \neq g$.
\end{itemize}



\subsection{Propagation des gaps}

Cette étape consiste à transformer le chemin hamiltonien construit à l'étape précédente en un ensemble de fragments alignés. Pour la suite, nous appellerons consécutifs deux arcs du chemin tels que la destination du premier est la source du second.

A chaque arc correspond un alignement semi-global entre les deux fragments qui sont les extrémités de cet arc.
Pour chaque paire d'arcs consécutifs du chemin, il faut donc aligner le $g$ obtenu depuis l'arc $f \to g$ avec le g obtenu depuis l'arc $g \to h$.


\begin{verbatim}
tccgaagtctgct----------------------------------
---------tgctgctggag---------------------------
----------actactag-gcc-------------------------
----------------ag-gtcaactgatc-----------------
---------------------caactg-ccaaaaa------------
----------------------aac---ccaaaaagggg--------
-----------------------------------gggggggtcggt
\end{verbatim}





Le chemin hamiltonien est un ensemble d'arcs 

La propagation des gaps consiste donc à aligner les paires consécutives, et à propager vers toutes les paires précédentes et suivantes les gaps induits par cet alignement.

Trois solutions ont été envisagées pour avoir un accès rapide au fragment voulu dans le chemin hamiltonien.
\begin{itemize}
\item Utiliser un arbre de recherche équilibré 
\item Utiliser une table de hachage permettant de retrouver un arc en fonction de sa destination ou de sa source


\item Utiliser une table de hachage permettant de retrouver un arc en fonction de sa source
\end{itemize}



Pour classer les fragments, d'abord pensé aux abr équilibrés (\textit{TreeSet}\footnote{https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html} de java), et puis hashmap

Pour stocker ces fragments en construction, il faut une structure permettant facilement l'insertion d'un caractère à un indice donné. Les \textit{LinkedList} de java, qui sont des listes doublement chaînées, ont été choisies.

\subsection{Vote de consensus}

Finalement, il ne reste qu'à construire le fragment qui sera donné en sortie. Ce dernier va être peu à peu contruit grace au $Vote de consensus$. Cet étape consiste pour chaque colonne du tableau qui a été construit lors de la propagation des gaps à en extraire le caractère le plus redondant, et ainsi obtenir le fragment à retourner.

Cepebdant il est possible que plusieurs caractères soient présent le même nombre de fois dans une colonne. Dans ce cas, le premier d'entre eux sera selectionné comme caractère du fragment à retourner.

\section{Qualité du projet}

Nous avons eu recours aux streams pour la construction des arcs du graphe. Le multithreading est la capacité à pouvoir effectuer plusieurs taches ($threads$) simultanément. Le principal avantage est le gain de temps très important qu'apporte cette méthode,. Cependant, comme les taches sont gérer en même temps , les résultats ne sont pas déterministes et peuvent engendrer des problèmes (+++ problèmes +++)

Durant la réalisation du projet une grande quantité de test ont été implémentés. Cela a permis non seulement de pouvoir détecter rapidement d'éventuelles erreurs, mais également de pouvoir continuer le travail sans avoir de doute quand aux différentes classes et méthodes déja implémentées.



\section{Conclusion}

(+++ j'ai pas fait le blabla dans le SGA juste la table (pour l'instant je m'en occupe si tu veux)  - est ce que scinder l'intro est une bonne idée ? - est ce qu'il fut rajouter du contenu dans l'intro ? -  la répartition du travail est brève je sais aps si ça leur suffira -  j'ai refais le vote de consensus -  qualité du projet incomplet selon moi - pas d'inspi pour la conclusion +++)

utilisation de structure donné nouvelle

progression nette7

cependant - amélioration du résultat (lacune en bio)


\end{document}