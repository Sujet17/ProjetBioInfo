\documentclass{article}
\usepackage[french]{babel}
%\usepackage[latin1]{inputenc}
\usepackage[utf8]{inputenc}  
%\usepackage[T1]{fontenc}
\usepackage[top = 3cm, left = 4cm, right = 4cm ]{geometry}
\usepackage[pdftex]{graphicx}
\usepackage{fancyhdr}
\usepackage{colortbl}
\usepackage{xcolor}
%\usepackage{lscape}
%\usepackage[absolute]{textpos}
%\usepackage{amssymb}

\definecolor{lightgreen}{rgb}{.5,1,.5}

\definecolor{lightred}{rgb}{1,.5,.5}

\title{
{\Huge \textbf{Rapport de projet}\\
Algorithmique et bioinformatique}}

\author{\textbf{Sneessens Joachim}\\\textbf{Tulippe-Hecq Arnaud}\\MA1 Info}


\date{Année Académique 2019-2020\\
Master 1 en sciences informatiques\\
\vspace{1cm}
Faculté des Sciences, Université de Mons}


\pagestyle{fancy}
\lhead{Sneessens J. - Tulippe-Hecq A.}
\rhead{MA1 Info}
\cfoot{\thepage}

\begin{document}

\maketitle

\vspace{9cm}

\begin{center}
\begin{tabular}[t]{c c c}
\includegraphics[height=1.5cm]{logoumons.jpg} &
\hspace{1cm} &
\includegraphics[height=1.5cm]{logofs.jpg}
\end{tabular}
\end{center}~\\



\newpage

\section{Introduction}

%Ce projet est réalisé dans le cadre du cours d'\textit{Algorithmique et BioInformatique} donné par le Prof. Olivier Delgrange.
%donné par les enseignants Olivier Delgrange et Clément Tamines, 

L'objectif de ce projet est l'implémentation d'une solution au problème d'assemblage de fragments d'ADN. Suite au séquençage de l'ADN, un ensemble de courts fragments est obtenu, et l'assemblage consiste à aligner/fusionner ces derniers afin de retrouver la séquence d'origine. Les fragments issus du séquençage peuvent provenir du brin $3' \to 5'$, ou de son complémentaire $5' \to 3'$, ainsi lorsqu'un fragment est présent dans l'ensemble issu du séquençage, son complémentaire inversé doit aussi être considéré dans la reconstruction de la séquence originale.

Plus précisément, le but de ce projet est de fournir un programme java prenant en entrée une collection de fragments et capable de reconstituer au mieux la séquence d'origine. Au vu de la grande taille des problèmes, une grande attention doit être portée à la complexité en temps et en mémoire. Certaines collections de fragments et leurs séquences cibles respectives sont à disposition pour permettre d'évaluer la qualité du programme (la comparaison entre la séquence cible et la séquence obtenue par le 
programme étant effectuée à l'aide de l'outil $dotmatcher$).
\textcolor{red}{Précisons que l'ADN n'est vu et traité que sous son abstraction en temps que chaîne de caractères.}

Les fragments reçus en entrée sont des chaînes des caractères (dont la longueur varie entre 500 et 700 caractères). Les différents caractères sont des $a$, $c$, $t$ et $g$ correspondant \textcolor{red}{respectivement à adénine, cytosine, thymine, guanine, qui sont} au différentes molécules de base constituant l'ADN.


\section{Organisation du travail}

Cette section traite des différents outils utilisés pour réaliser ce projet, de la répartition des tâches au sein du groupe ainsi que 

Ce projet est implémenté sous \textit{java 11}. 

Plutôt que d'assigner à chaque membre du groupe des parties entières du travail, nous avons choisi de travailler simultanément sur les mêmes parties du projet. 

Ce travail a été réalisé en plusieurs semaines. La quantité de travail à accomplir nous a poussé à avoir recours au logiciel $Git$ afin de pouvoir travailler à distance. De nombreuses séances de travail à l'université ont également été organisées. La totalité des étapes du travail, allant de la réflexion à l'implémentation ont été accomplies en duo.

Malgré un retard marqué par une première séance de mise au point peu développée, nous avons pu progresser à grande vitesse pour pouvoir organiser un seconde mise au point et ainsi nous mettre à jour par rapport au temps restant.

\newpage

\section{\'Etapes clés}

Les différentes étapes à suivre du projet nous ont été présentées lors de la séance de présentation du projet. Le prochain paragraphe décrit brièvement leurs places respectives dans l'assemblage de fragments.

La première étape de cet algorithme consiste à construire un graphe dit \textit{overlap graph} dont les sommets sont les fragments   et les arcs sont les poids des alignements semi-globaux entre ces fragments.
Ensuite vient la construction d'un chemin hamiltonien sur ce graphe par un algorithme glouton.
L'avant dernière étape consiste à aligner tous les fragments selon l'ordre obtenu dans le chemin hamiltonien en ajoutant des gaps si nécessaire. On parle de propagation des gaps.
Finalement intervient le vote de consensus qui, d'après l'ensemble de fragments alignés obtenus après la propagation des gaps, déterminera la séquence finale que retournera le programme.

Les sections suivantes sont consacrées à une explication plus approfondie de chacune de ces étapes clés, chacune décrivant d'abord précisément dans le rôle de l'étape avant de s'attarder sur les choix d'implémentation propres à notre projet.

\subsection{Alignement semi-global}

L'alignement semi-global entre deux fragments est utilisé pour construire l'\textit{overlap graph}. \textcolor{red}{L'alignement semi-global vise à mesurer la ressemblance entre deux fragments sans pénaliser le décalage.} 

C'est aussi à cette étape que sont détectées les inclusions entre fragments.

L'arc $f \to g$ dans l'\textit{overlap graph} aura pour poids le score de l'alignement semi-global dans lequel $f$ finit par des gaps et $g$ commence par des gaps lorsqu'ils sont alignés.


Pour calculer cet alignement semi-global, on utilise la programmation dynamique.

Le tableau suivant montre la matrice calculée pour déterminer les alignements $f \to g$ et $g \to f$, avec $f =$ acaatgatc et $g =$ caagatcagga.

\begin{table}[h]
	\centering
	\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
		\hline
		&& C & A & A & G & A & T & C & A & G & G & A\\		
		\hline
		& 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cellcolor{lightgreen}0 & 0  \\
		\hline 
		A&\cellcolor{lightred}0 & -1 & 1 & 1 & -1 & 1 & -1 & -1 & 1 & -1 & -1 &\cellcolor{lightgreen}1 \\
		\hline 
		C&0 & \cellcolor{lightred}1 & -1 & 0 & 0 & -1 & 0 & 0 & -1 & 0 & -2 & -1 \\
		\hline 
		A&0 & -1 & \cellcolor{lightred}2 & 0 & -1 & 1 & -1 & -1 & 1 & -1 & -1 & -1  \\
		\hline 
		A&0 & -1 & 0 & \cellcolor{lightred}3 & 1 & 0 & 0 & -2 & 0 & 0 & -2 & 0 \\
		\hline 
		T&0 & -1 & -2 & \cellcolor{lightred}1 & 2 & 0 & 1 & -1 & -2 & -1 & -1 & -2  \\
		\hline 
		G&0 & -1 & -2 & -1 & \cellcolor{lightred}2 & 1 & -1 & 0 & -2 & -1 & 0 & -2  \\
		\hline 
		A&0 & -1 & 0 & -1 & 0 & \cellcolor{lightred}3 & 1 & -1 & 1 & -1 & -2 & 1  \\
		\hline 
		T&0 & -1 & -2 & -1 & -2 & 1 & \cellcolor{lightred}4 & 2 & 0 & 0 & -2 & -1  \\
		\hline 
		C&0 & 1 & -1 & -3 & -2 & -1 & 2 & \cellcolor{lightred}5 & 3 & 1 & -1 & -3  \\
		\hline 
	\end{tabular}
\end{table}

$g \to f$
\begin{verbatim}
caagatcagga--------
----------acaatgatc
\end{verbatim}

$f \to g$
\begin{verbatim}
acaatgatc----
-caa-gatcagga
\end{verbatim}

\subsection{Overlap graph}

La première étape de cet algorithme est la construction de l'overlap graph. Il s'agit de créer un graphe dont les sommets sont les fragments donnés en entrée et leurs complémentaires-inversés. Ce graphe est orienté et pondéré. Un arc $f\to g$ de poids $w$ existe entre $f$ et $g$ si l'alignement semi-global entre $f$ et $g$ est de poids $w$.

Pour construire ce graphe, il faut donc rechercher l'alignement semi-global optimal pour chaque paire de fragments du graphe (excepté les paires constituées d'un fragment et son complémentaire-inversé).

Nous avons pris le parti de retirer du graphe les fragments inclus à d'autres.

Puisque le graphe est construit dans l'unique but de parcourir les arcs par ordre décroissant pour construire le chemin hamiltonien, nous avons choisi de mettre tous les arcs dans un tas où ils seraient triés en fonction de leur poids.

\textit{PriorityBlockingQueue}\footnote{https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/PriorityBlockingQueue.html}

Pour la suite, nous nommerons $f'$ le fragment complémentaire-inversé d'un fragment $g$. 

Chaque nœud d'un graphe contient un fragment $f$ et son complémentaire-inversé $f'$. Ce choix est expliqué dans la section suivante.

Conséquemment, chaque arc du graphe est caractérisé par sa source, sa destination, son poids, un

La construction du graphe est l'étape la plus coûteuse de l'assemblage de fragments. -> multithreading grâce aux streams.



\subsection{Chemin hamiltonien}

Pour construire le chemin hamiltonien, nous allons retirer successivement sa racine au tas qui contient les arcs pour parcourir les arcs dans l'ordre décroissant. L'algorithme utilisé est très proche de l'algorithme de Kruskal, qui sert à la construction de l'arbre couvrant de poids minimal d'un graphe.
Pendant ce parcours des arcs, un arc $f \to g$ est accepté dans le chemin hamiltonien si :

\begin{itemize}
\item pour tous les arcs $i \to j$ déjà choisis dans le chemin, $i \neq f'$ et $j \neq f'$  ($f'$ étant le complémentaire-inversé de $f$)
\item pour tous les arcs $i \to j$ déjà choisis dans le chemin, $i \neq g'$ et $j \neq g'$  ($g'$ étant le complémentaire-inversé de $g$)
\item ajouter $f \to g$ au chemin ne va pas créer de cycle
\item pour tous les arcs $i \to j$ déjà choisis dans le chemin, $i \neq f$ et $j \neq g$.
\end{itemize}

L'algorithme s'arrête quand tous les sommets du graphe sont traversés par le chemin créé.

Concernant nos choix d'implémentation, nous 

\subsection{Propagation des gaps}

L'étape de propagation des gaps consiste à aligner les différents fragments du chemin hamiltonien construit à l'étape précédente.
\textcolor{red}{
Cette étape consiste à transformer le chemin hamiltonien construit à l'étape précédente en un ensemble de fragments alignés. Pour la suite, nous appellerons consécutifs deux arcs du chemin tels que la destination du premier est la source du second.}

Pour réaliser cet alignement de nombreux fragments, il faut, pour chaque paire d'arcs consécutifs du chemin hamiltonien (i.e., chaque paire d'arcs $f \to g$ et $g \to h$), aligner le $g$ obtenu dans l'alignement $f \to g$ avec le $g$ obtenu dans l'alignement $g \to h$, en propageant vers le haut et vers le bas tous les gaps nécessaires.

\textcolor{red}{
La propagation des gaps consiste donc à aligner les paires consécutives, et à propager vers toutes les paires précédentes et suivantes les gaps induits par cet alignement.}

Pour illustrer, prenons les fragments $f =$ acaatgatc, $g =$ caagatcagga et $h =$ agagtcaggacc et considérons le chemin hamiltonien $f \to g \to h$.


\begin{verbatim}
caaga-tcagga--
--agagtcaggacc
\end{verbatim}

A chaque arc correspond un alignement semi-global entre les deux fragments qui sont les extrémités de cet arc.
Pour chaque paire d'arcs consécutifs du chemin, il faut donc aligner le $g$ obtenu depuis l'arc $f \to g$ avec le g obtenu depuis l'arc $g \to h$.


\begin{verbatim}
tccgaagtctgct----------------------------------
---------tgctgctggag---------------------------
----------actactag-gcc-------------------------
----------------ag-gtcaactgatc-----------------
---------------------caactg-ccaaaaa------------
----------------------aac---ccaaaaagggg--------
-----------------------------------gggggggtcggt
\end{verbatim}


Ici vont être abordées les spécificités propres à notre implémentation. La première question qui s'est posée au moment d'implémenter la propagation des gaps était relative à la structure de données utilisée pour stocker l'ensemble d'arcs utilisés par le chemin hamiltonien. 
Pour réaliser l'alignement de tous les fragments, il faut aligner tous les arcs consécutifs. Cela signifie qu'il faut pouvoir trouver facilement l'arc suivant (ou précédent) dans le chemin hamiltonien.

Trois solutions ont été envisagées pour avoir un accès rapide au fragment voulu dans le chemin hamiltonien.
\begin{itemize}
\item Utiliser un arbre de recherche équilibré 
\item Utiliser une table de hachage permettant de retrouver un arc en fonction de sa destination ou de sa source
\item Utiliser une table de hachage permettant de retrouver un arc en fonction de sa source
\end{itemize}

Pour classer les fragments, d'abord pensé aux abr équilibrés (\textit{TreeSet}\footnote{https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html} de java), et puis hashmap

Pour stocker ces fragments en construction, il faut une structure permettant facilement l'insertion d'un caractère à un indice donné. Les \textit{LinkedList}\footnote{https://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html} de java, qui sont des listes doublement chaînées, ont été choisies. Dans une première implémentation, naïve, une liste chaînée était utilisée pour stocker l'ensemble des caractères des fragments alignés. Ainsi, lorsqu'un gap devait être propagé vers le haut, il devait être inséré dans les $k$ fragments déjà traités. Et lorsqu'un gap devait être propagé vers le bas, 

Le problème de cette implémentation est qu'elle rendait très longue l'étape de propagation des gaps (plus d'une demi-heure sur la plus grande collection de fragments à disposition). 

Parmi les raisons provoquant un tel délai, nous avons d'abord pensé à :
- l'accès en O(index) dans les listes chainées (mais utiliser iterator n'a pas résolu problème)
- Devoir ajouter un nombre très important de gaps derrière fragments du début et devant ceux de la fin. En effet, si les fragments ont une taille allant de 500 à 700 caractères, leur version alignée dans cette étape a une taille proche de celle de la séquence cible (environ $100.000$ caractères pour la plus grande collection). Cela signifie que l'on passait énormément de temps à ajouter des gaps devant et derrière ces chaînes, sans plus toucher à l'information consistance rassemblée sur 500 à 700 caractères parmi les $100.000$.
Nous étant rendus compte que les fragments en construction étaient constitués essentiellement de gaps (plus précisément d'un grand nombre de gaps suivis de 500 à 700 caractères, eux-mêmes suivis d'un grand nombre de gaps), nous avons décidé d'adapter la structure de ces \textit{FragmentBuilder} pour consommer moins d'espace et permettre des opérations plus rapides.

Expliquer la structure des fragmentsBuider + gain de temps

+ Petite optimisation : arrêter de propager les gaps vers le haut quand on sait qu'ils seront après la zone d'information consistante


\subsection{Vote de consensus}

Dernière de l'assemblage, le vote de consensus est l'étape où est construit le fragment qui sera donné en sortie. Il s'agit de retourner un fragment tel que son $i^{eme}$ caractère est le caractère le plus présent dans la $i^{eme}$ colonne du tableau construit pendant lors de la propagation des gaps.

Pour cette étape, notre implémentation consiste simplement à compter, pour chaque colonne, le nombre d’occurrences de chaque caractère (en ignorant les gaps) et à placer ensuite ce caractère au bon indice dans la séquence résultat.
En cas d'égalité entre deux caractères, le caractère résultant est choisi selon l'ordre arbitraire suivant (ici classés par ordre de préférence décroissante) : a, t, c, g.

\section{Qualité du projet}

Nous avons eu recours aux streams pour la construction des arcs du graphe. Le multithreading est la capacité à pouvoir effectuer plusieurs taches ($threads$) simultanément. Le principal avantage est le gain de temps très important qu'apporte cette méthode. Cependant, comme les taches sont gérer en même temps , les résultats peuvent ne pas être cohérent. Le problème majeur de cette méthode est le non déterminisme des résultats.

Durant la réalisation du projet une grande quantité de tests ont été implémentés. Cela a permis non seulement de pouvoir détecter rapidement d'éventuelles erreurs, mais également de pouvoir continuer le travail sans avoir de doute quand aux différentes classes et méthodes déja implémentées.



\section{Conclusion}

(+++ j'ai pas fait le blabla dans le SGA juste la table (pour l'instant je m'en occupe si tu veux)  - est ce que scinder l'intro est une bonne idée ? - est ce qu'il fut rajouter du contenu dans l'intro ? -  la répartition du travail est brève je sais aps si ça leur suffira -  j'ai refais le vote de consensus -  qualité du projet incomplet selon moi - pas d'inspi pour la conclusion +++)

utilisation de structure donné nouvelle

progression nette7

cependant - amélioration du résultat (lacune en bio)


\end{document}